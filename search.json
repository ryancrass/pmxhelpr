[{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":[]},{"path":"https://ryancrass.github.io/pmxhelpr/articles/eda-pmxhelpr.html","id":"overview-of-plot_dvtime","dir":"Articles","previous_headings":"Population Concentration-time plots","what":"Overview of plot_dvtime","title":"Exploratory Data Analysis with pmxhelpr","text":"Let’s visualize data. Let’s visualize data. visualization, leverage functionality plot_dvtime visualize data. First, filter observation records derive factor variable DOSE pass color aesthetic. Now let’s visualize concentration-time data. pmxhelpr includes function common visualizations observed concentration-time data exploratory data analysis: plot_dvtime visualizations, leverage following dataset variables: + ODV: original dependent variable (drug concentration) untransformed units (ng/mL) + TIME : actual time since first dose (hours) + NTIME: nominal time since first dose (hours) + LLOQ : lower limit quantification drug concentration plot_dvtime requires dependent variable (specified named vector using dv_var argument) time variable (specifed named vector using time_vars). dependent variable data_sad named \"ODV\", must specify name using dv_var. default names time_vars \"TIME\" \"NTIME\". color aesthetic specified using col_var argument. cent argument specifies central tendency measure plotted.  bad plot minimal arguments! can see mean dose colored thick line observed data points colored open circles alpha added. caption also prints default indicating plot elements depict. caption can removed specifying show_caption = FALSE.  However, plot misleading! food effect fasted portions study pooled together within 100 mg dose! Also, data likely better visualized using log-scale y-axis, x-axis breaks optimized study design.","code":"plot_data <- data_sad %>%    filter(EVID == 0) %>%    mutate(`Dose (mg)` = factor(DOSE),           DNDV = ODV/DOSE) plot_dvtime(data = plot_data, dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", cent = \"mean\",              ylab = \"Concentration (ng/mL)\", xlab = \"Time (hours)\") plot_dvtime(data = plot_data, dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", cent = \"mean\",              ylab = \"Concentration (ng/mL)\", xlab = \"Time (hours)\", show_caption = FALSE)"},{"path":"https://ryancrass.github.io/pmxhelpr/articles/eda-pmxhelpr.html","id":"adjusting-plot-aesthetics","dir":"Articles","previous_headings":"Population Concentration-time plots","what":"Adjusting plot aesthetics","title":"Exploratory Data Analysis with pmxhelpr","text":"Luckily, plot_dvtime returns ggplot object can modify like ggplot! Therefore, add manual x-axis scale, facet PART, apply minimal plot theme.  Much better aesthetics! still need log-transform y-axis better visualize terminal phase profile. specify log10 y-axis transformation adding scale_y_log10(); however, plot_dvtime includes argument log_y performs operation one added benefit using automatically generated plot captions show_captions = TRUE. plot_dvtime uses stat_summary function ggplot2 calculate plot central tendency measures error bars. often overlooked feature stat_summary, calculates summary statistics transformations data performed changing scales. means scale_y_log10() applied plot, data log-transformed plotting central tendency measure returned requesting \"mean\" stat_summary geometric mean. log_y argument used generate semi-log plots along show_captions = TRUE, caption clearly delineate arithmetic gemoetric means returned.  clinical team like simpler plot clearly displays central tendency. can use argument cent = \"mean_sdl\" plot mean error bars remove observed points specifying obs_dv = FALSE.  Hmm…noise late terminal phase. likely artifact introduced censoring data assay LLOQ; however, let’s confirm weird individual subject profiles connecting observed data points longitudinally within subject - words, make spaghetti plot. change central tendency measure median add spaghetti lines. Data points within individual connected narrow line ind_dv = TRUE  seem like outlier individuals driving noise late terminal phase; therefore, almost certainly artifact introduced data missing due assay sensitivity censoring lower limit quantification (LLOQ).","code":"plot_dvtime(data = plot_data, dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", cent = \"mean\",              ylab = \"Concentration (ng/mL)\", xlab = \"Time (hours)\") +   scale_x_continuous(breaks = seq(0,168,24))+   facet_wrap(~PART)+   theme_bw() plot_dvtime(data = plot_data, dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", cent = \"mean\",              ylab = \"Concentration (ng/mL)\", xlab = \"Time (hours)\", log_y = TRUE) +   scale_x_continuous(breaks = seq(0,168,24))+   facet_wrap(~PART)+   theme_bw() plot_dvtime(data = plot_data, dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", cent = \"mean_sdl\",              ylab = \"Concentration (ng/mL)\", xlab = \"Time (hours)\", log_y = TRUE,             obs_dv = FALSE) +   scale_x_continuous(breaks = seq(0,168,24))+   facet_wrap(~PART)+   theme_bw() plot_dvtime(data = plot_data, dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", cent = \"median\",              ylab = \"Concentration (ng/mL)\", xlab = \"Time (hours)\", log_y = TRUE,              ind_dv = TRUE) +   scale_x_continuous(breaks = seq(0,168,24))+   facet_wrap(~PART)+   theme_bw()"},{"path":"https://ryancrass.github.io/pmxhelpr/articles/eda-pmxhelpr.html","id":"defining-imputations-for-blq-data","dir":"Articles","previous_headings":"Population Concentration-time plots","what":"Defining imputations for BLQ data","title":"Exploratory Data Analysis with pmxhelpr","text":"Let’s use imputation assess potential impact data missing due assay sensitivity. plot_dvtime includes functionality imputation us using loq loq_method arguments. loq_method argument species BLQ imputation performed. Options : + 0 : handling. Plot input dataset DV vs TIME . (default) + 1 : Impute BLQ data TIME <= 0 0 BLQ data TIME > 0 1/2 x loq. Useful plotting concentration-time data data BLQ linear scale + 2 : Impute BLQ data TIME <= 0 1/2 x loq BLQ data TIME > 0 1/2 x loq. loq argument species value LLOQ. loq argument must specified loq_method 1 2, can NULL variable LLOQ present dataset. case, LLOQ variable plot_data, need specify loq argument (default loq = NULL).  plot obtained specifying loq = 1  reference line drawn denote LLOQ observations EVID=0 MDV=1 imputated LLOQ/2. Imputing post-dose concentrations lower limit quantification 1/2 x LLOQ normalizes late terminal phase concentration-time profile. confirmatory evidence hypothesis noise late terminal phase due censoring observations LLOQ.","code":"plot_dvtime(plot_data, dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", cent = \"mean\",             ylab = \"Concentration (ng/mL)\", xlab = \"Time (hours)\", log_y = TRUE,             loq_method = 2) +   scale_x_continuous(breaks = seq(0,168,24))+   facet_wrap(~PART)+   theme_bw() plot_dvtime(plot_data, dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", cent = \"mean\",             ylab = \"Concentration (ng/mL)\", xlab = \"Time (hours)\", log_y = TRUE,             loq_method = 2, loq = 1) +   scale_x_continuous(breaks = seq(0,168,24))+   facet_wrap(~PART)+   theme_bw()"},{"path":"https://ryancrass.github.io/pmxhelpr/articles/eda-pmxhelpr.html","id":"dose-normalization","dir":"Articles","previous_headings":"Population Concentration-time plots","what":"Dose-normalization","title":"Exploratory Data Analysis with pmxhelpr","text":"can also generate dose-normalized concentration-time plots specifying dosenorm = TRUE.  dosenorm = TRUE, variable DOSE needs present input dataset data. DOSE present data, function return Error informative error message. Dose-normalization performed BLQ imputation case options requested. reference line LLOQ plotted dose-normalized concentration dependent variable.","code":"plot_dvtime(plot_data, dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", cent = \"mean\",             ylab = \"Dose-normalized Concentration (ng/mL per mg Drug)\", xlab = \"Time (hours)\", log_y = TRUE,             dosenorm = TRUE) +   scale_x_continuous(breaks = seq(0,168,24))+   facet_wrap(~PART)+   theme_bw() plot_dvtime(select(plot_data, -DOSE),              dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", cent = \"mean\",             ylab = \"Dose-normalized Concentration (ng/mL per mg Drug)\", xlab = \"Time (hours)\", log_y = TRUE,             dosenorm = TRUE) +   scale_x_continuous(breaks = seq(0,168,24))+   facet_wrap(~PART)+   theme_bw() #> Error in `check_varsindf()`: #> ! argument `\"DOSE\"` must be variables in `data` plot_dvtime(plot_data, dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", cent = \"mean\",             ylab = \"Dose-normalized Concentration (ng/mL per mg Drug)\", xlab = \"Time (hours)\", log_y = TRUE,             loq_method = 2, dosenorm = TRUE) +   scale_x_continuous(breaks = seq(0,168,24))+   facet_wrap(~PART)+   theme_bw()"},{"path":"https://ryancrass.github.io/pmxhelpr/articles/eda-pmxhelpr.html","id":"individual-concentration-time-plots","dir":"Articles","previous_headings":"","what":"Individual Concentration-time plots","title":"Exploratory Data Analysis with pmxhelpr","text":"previous section provides overview generate population concentration-time profiles dose using plot_dvtime; however, can also use plot_dvtime generate subject-level visualizations little pre-processing input dataset. can specify cent = \"none\" remove central tendency layer plotting individual subject data.  can plot individual subject filtering input dataset. extended generate plots individuals using loops, purrr::map() functions, vectorized methods.","code":"plot_dvtime(plot_data, dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", cent = \"none\",             ylab = \"Concentration (ng/mL)\", xlab = \"Time (hours)\", log_y = TRUE,             ind_dv = TRUE,             loq_method = 2, loq = 1) +   scale_x_continuous(breaks = seq(0,168,24))+   facet_wrap(~PART)+   theme_bw() ids <- sort(unique(plot_data$ID)) plotlist<- list() for(i in 1:length(ids)){   plotlist[[i]] <- plot_dvtime(filter(plot_data, ID == ids[i]),                                 dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", cent = \"none\",             ylab = \"Concentration (ng/mL)\", xlab = \"Time (hours)\", log_y = TRUE,             ind_dv = TRUE,             loq_method = 2, loq = 1, show_caption = FALSE) +   scale_x_continuous(breaks = seq(0,168,24))+   facet_wrap(~PART)+   labs(title = paste0(\"ID = \", ids[i], \" | Dose = \", unique(plot_data$DOSE[plot_data$ID==ids[i]]), \" mg\"))+   theme_bw()+   theme(legend.position=\"none\") }   groups <- length(plotlist)/4 for(grp in 1:groups){   i <- (grp-1)*4+1   j <- grp*4   plist <- plotlist[i:j]   patchwork::wrap_plots(plist) }"},{"path":"https://ryancrass.github.io/pmxhelpr/articles/vpc-exact-bins.html","id":"exploratory-data-analysis","dir":"Articles","previous_headings":"","what":"Exploratory Data Analysis","title":"VPC Plots with Exact Bins","text":"Next let’s explore input dataset, data_sad. dataset generated via simulation model, mrgsolve model internal pmxhelpr package. can take quick look dataset using glimpse() dplyr package. can see dataset already formatted modeling. contains NONMEM reserved variables (e.g., ID, TIME, AMT, EVID, MDV), well , dependent variables drug concentration original units (ODV) natural logarithm transformed units (LDV). addition numeric variables, two character variables: USUBJID PART. PART specifies two study cohorts: Single Ascending Dose (SAD) Food Effect (FE). dataset also contains exact binning variable: Nominal Time (NTIME). variable represents nominal time sample collection relative first dose per study protocol whereas Actual Time (TIME) represents actual time sample collected.","code":"glimpse(data_sad) #> Rows: 720 #> Columns: 23 #> $ LINE    <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,… #> $ ID      <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,… #> $ TIME    <dbl> 0.00, 0.00, 0.48, 0.81, 1.49, 2.11, 3.05, 4.14, 5.14, 7.81, 12… #> $ NTIME   <dbl> 0.0, 0.0, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0, 5.0, 8.0, 12.0, 16.0, … #> $ NDAY    <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 4, 5, 6, 7, 8, 1,… #> $ DOSE    <dbl> 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10… #> $ AMT     <dbl> NA, 10, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ EVID    <dbl> 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… #> $ ODV     <dbl> NA, NA, NA, 2.02, 4.02, 3.50, 7.18, 9.31, 12.46, 13.43, 12.11,… #> $ LDV     <dbl> NA, NA, NA, 0.7031, 1.3913, 1.2528, 1.9713, 2.2311, 2.5225, 2.… #> $ CMT     <dbl> 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… #> $ MDV     <dbl> 1, NA, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1… #> $ BLQ     <dbl> -1, NA, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, … #> $ LLOQ    <dbl> 1, NA, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… #> $ FOOD    <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… #> $ SEXF    <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,… #> $ RACE    <dbl> 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1,… #> $ AGEBL   <int> 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25… #> $ WTBL    <dbl> 82.1, 82.1, 82.1, 82.1, 82.1, 82.1, 82.1, 82.1, 82.1, 82.1, 82… #> $ SCRBL   <dbl> 0.87, 0.87, 0.87, 0.87, 0.87, 0.87, 0.87, 0.87, 0.87, 0.87, 0.… #> $ CRCLBL  <dbl> 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 12… #> $ USUBJID <chr> \"STUDYNUM-SITENUM-1\", \"STUDYNUM-SITENUM-1\", \"STUDYNUM-SITENUM-… #> $ PART    <chr> \"Part 1-SAD\", \"Part 1-SAD\", \"Part 1-SAD\", \"Part 1-SAD\", \"Part … unique(data_sad$PART) #> [1] \"Part 1-SAD\" \"Part 2-FE\" ##Unique values of NTIME unique(data_sad$NTIME) #>  [1]   0.0   0.5   1.0   1.5   2.0   3.0   4.0   5.0   8.0  12.0  16.0  24.0 #> [13]  36.0  48.0  72.0  96.0 120.0 144.0 168.0  ##Comparison of number of unique values of NTIME and TIME length(unique(data_sad$NTIME)) #> [1] 19 length(unique(data_sad$TIME)) #> [1] 449"},{"path":"https://ryancrass.github.io/pmxhelpr/articles/vpc-exact-bins.html","id":"pk-model","dir":"Articles","previous_headings":"","what":"PK Model","title":"VPC Plots with Exact Bins","text":"Luckily us, someone already fit PK model data! Let’s load model calling model_mread_load() take look see() function mrgsolve package. Unluckily us, one validated PK model! Therefore, need generate Visual Predictive Checks (VPCs).","code":"model <- model_mread_load(\"model\") #> Building model_cpp ... done. see(model) #>  #> Model file:  model.cpp  #> $PARAM  #> TVCL = 20 #> TVVC = 35.7 #> TVKA = 0.3 #> TVQ = 25 #> TVVP = 150 #> DOSE_F1 = 0.33 #>  #> WT_CL = 0.75 #> WT_VC = 1.00 #> WT_Q = 0.75 #> WT_VP = 1.00 #> FOOD_KA = -0.5 #> FOOD_F1 = 1.33 #>  #> WT = 70 #> DOSE = 100 #> FOOD = 0 #>  #> $CMT GUT CENT PERIPH TRANS1 TRANS2 #>  #> $MAIN #> double CL = TVCL*pow(WT/70,WT_CL)*exp(ETA_CL); #> double VC  = TVVC*pow(WT/70, WT_VC)*exp(ETA_VC); #> double Q = TVCL*pow(WT/70,WT_Q)*exp(ETA_Q); #> double VP  = TVVP*pow(WT/70, WT_VP)*exp(ETA_VP); #> double KA = TVKA*(1+FOOD_KA*FOOD)*exp(ETA_KA); #> double F1 = 1*(1+FOOD_F1*FOOD)*pow(DOSE/100,DOSE_F1); #>  #> F_GUT = F1; #>  #> $ODE #> dxdt_GUT = -KA*GUT; #> dxdt_CENT = KA*TRANS1 - (CL/VC)*CENT + (Q/VP)*PERIPH - (Q/VC)*CENT; #> dxdt_PERIPH = (Q/VC)*CENT - (Q/VP)*PERIPH; #> dxdt_TRANS1 = KA*GUT - KA*TRANS1; #> dxdt_TRANS2 = KA*TRANS1 - KA*TRANS2; #>  #> $OMEGA @labels ETA_CL ETA_VC ETA_KA ETA_Q ETA_VP #> 0.075 0.1 0.2 0 0  #>  #> $SIGMA @labels PROP #> 0.09 #>  #> $TABLE #> capture IPRED = CENT/(VC/1000); #> capture DV = IPRED*(1+PROP);"},{"path":[]},{"path":"https://ryancrass.github.io/pmxhelpr/articles/vpc-exact-bins.html","id":"running-the-simulation","dir":"Articles","previous_headings":"VPC Plot Workflow","what":"Running the simulation","title":"VPC Plots with Exact Bins","text":"use df_mrgsim_replicate() run simulation VPC. df_mrgsim_replicate() wrapper function mrgsim_df(), uses lapply() iterate simulation integers 1 value passed argument replicates. can pass data_sad model previous steps data model arguments, respectively, run simulation 100 replicates. names actual nominal time variables data_sad match default arguments; however, dependent variable named \"ODV\", must specified output_vars argument. Note: Currently output variables IPRED DV required model capture statement like recover numerical variables \"DOSE\" \"FOOD\" character variable \"PART\" input dataset, may need study conditions stratify VPC plots. request \"BLQ\" \"LLOQ\" potential assessment impact censoring VPCs, well , NONMEM reserved variables \"CMT\", \"EVID\", \"MDV\". Finally, add argument obsonly = TRUE, passed mrgsim(), remove dose records simulation output reduce file size. maximum value replicate count variable (default = \"SIM\") indicates dataset replicated 100 times. Glimpsing output reveals following model outputs: PRED (population prediction) IPRED (individual prediction) SIMDV (simulated dependent variable) OBSDV (observed dependent variable).","code":"simout <- df_mrgsim_replicate(data = data_sad,                       model = model,                       replicates = 100,                       time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),                      output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", DV = \"ODV\"),                      num_vars = c(\"CMT\", \"BLQ\", \"LLOQ\", \"EVID\", \"MDV\", \"DOSE\", \"FOOD\"),                      char_vars = c(\"PART\"),                      obsonly = TRUE)  glimpse(simout) #> Rows: 68,400 #> Columns: 21 #> $ ID     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, … #> $ TIME   <dbl> 0.00, 0.48, 0.81, 1.49, 2.11, 3.05, 4.14, 5.14, 7.81, 12.08, 16… #> $ PRED   <dbl> 0.0000000000, 1.0373644222, 2.4699025938, 5.8692716205, 8.67222… #> $ IPRED  <dbl> 0.00000000000, 0.23991271053, 0.58097762508, 1.44344928000, 2.2… #> $ SIMDV  <dbl> 0.0000000000, 0.2070745747, 0.6769646573, 1.8613297145, 1.74160… #> $ OBSDV  <dbl> NA, NA, 2.02, 4.02, 3.50, 7.18, 9.31, 12.46, 13.43, 12.11, 11.0… #> $ EVID   <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … #> $ CMT    <dbl> 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, … #> $ NTIME  <dbl> 0.0, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0, 5.0, 8.0, 12.0, 16.0, 24.0, … #> $ BLQ    <dbl> -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, -1, 0… #> $ LLOQ   <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … #> $ MDV    <dbl> 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, … #> $ DOSE   <dbl> 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,… #> $ FOOD   <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … #> $ GUT    <dbl> 0.00000000000000000, 4.34652773939926984, 4.13276198317304821, … #> $ CENT   <dbl> 0.000000000000, 0.009786371098, 0.023698880423, 0.058880291437,… #> $ PERIPH <dbl> 0.00000000000, 0.00080390625, 0.00337854545, 0.01621962833, 0.0… #> $ TRANS1 <dbl> 0.0000000000000000, 0.3188382667608536, 0.5115783540267899, 0.8… #> $ TRANS2 <dbl> 0.00000000000000, 0.01169414527583, 0.03166313774719, 0.0965661… #> $ PART   <chr> \"Part 1-SAD\", \"Part 1-SAD\", \"Part 1-SAD\", \"Part 1-SAD\", \"Part 1… #> $ SIM    <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …  max(simout$SIM) #> [1] 100"},{"path":"https://ryancrass.github.io/pmxhelpr/articles/vpc-exact-bins.html","id":"vpc-plots-with-the-vpc-package","dir":"Articles","previous_headings":"VPC Plot Workflow","what":"VPC plots with the vpc package","title":"VPC Plots with Exact Bins","text":"Now run simulation, generate VPC plots using vpc().documentation vpc() (https://vpc.ronkeizer.com/binning.html) describes following binning methods: time: Divide bins equally time (whatever independent variable used). Recommended observable clustering independent variable. data: Divide bins equally amount data ordered independent variable. Recommended data nominal timepoints datapoints available. density: Divide bins based data-density, .e. place bin-separators nadirs density function. approximate number bins can specified, certain algorithm strictly use specified number. info ?auto_bin(). jenks: Default recommended method. Jenk’s natural breaks optimization, similar K-means clustering. kmeans: K-means clustering. pretty, quantile, hclust, sd, bclust, fisher. Methods provided classInt package, see package help information. can visualize bins assigned various binning approaches vpc() using assigning plot object , let’s call plot_object, calling plot_object$data. multiple dose levels SAD portion study, well , food effect cohort, prediction-correction used plot data single plot using argument pred_corr = TRUE.  plot looks pretty good! default binning vpc::vpc() produce nice looking plot. However, binning methods internal vpc() designed determine binning intervals data. Currently, method use exact bins contained data place bin intervals determined data. presence exact bins data common scenario pharmacometrics, Clinical Study Protocols usually specify specific Study Visits corresponding ot sample, associated nominal (protocol-specified) time collection. can use df_nobsbin() function calculate return summary data.frame containing unique exact bin times, count non-missing observations (EVID=0 & MDV=0), count missing (EVID=0 & MDV=1) observations. bin_mid variable wherevpc() plot summary statistics calculated observed simulated data. can clearly see default bins = \"jenks\" method reproduce exact bins observed dataset, even passing nominal, rather actual, time independent variable (idv). binning methods native vpc()? Let’s take look bins = \"pretty\" next.  vpc plot produced bins = \"pretty fairly pretty; however, can see binning true exact bins dataset, especially earlier absorption phase time-points, largely binned together. bins = \"kmeans\" option produces yet another reasonable plot; however, like bins = \"pretty\", groups many absorption phase timepoints together include last three sampling times quantifiable observations simulated intervals.  native binning method density attempts bin data finding nadir density function. case, can try inform binning algorithm many bins expect data. Let’s pass length vector unique NTIME values dataset n_bins argument see density approach can find correct bins.  Whomp Whomp. bins = \"density\", like previous methods evaluated, grouped absorption phase single bin. leaves us two methods divide data equally bins range values data: bins = \"data\" (equal data density bin) bins = \"time\" (equal bin width time).   methods designed equalize data density bin, produce binning consistent exact bins dataset.","code":"vpc_jenks <- vpc(   sim = simout,    obs = filter(simout, SIM == 1),    bins = \"jenks\", #default   n_bins = \"auto\",    sim_cols = list(dv = \"SIMDV\", idv = \"NTIME\", pred = \"PRED\"),   obs_cols = list(dv = \"OBSDV\", idv = \"NTIME\", pred = \"PRED\"),   pred_corr = TRUE,   pi = c(0.05, 0.95),   ci = c(0.05, 0.95),   show = list(obs_dv = TRUE),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"PRED-corrected Concentration (ng/mL)\" ) +   scale_x_continuous(breaks = seq(0,168,24))  vpc_jenks ##Exact bins in the input data df_nobsbin(data_sad, bin_var = \"NTIME\") #> # A tibble: 19 × 4 #>    NTIME   CMT n_obs n_miss #>    <dbl> <dbl> <int>  <int> #>  1   0       2     0     36 #>  2   0.5     2    34      2 #>  3   1       2    36      0 #>  4   1.5     2    36      0 #>  5   2       2    36      0 #>  6   3       2    36      0 #>  7   4       2    36      0 #>  8   5       2    36      0 #>  9   8       2    36      0 #> 10  12       2    36      0 #> 11  16       2    36      0 #> 12  24       2    36      0 #> 13  36       2    36      0 #> 14  48       2    33      3 #> 15  72       2    29      7 #> 16  96       2    16     20 #> 17 120       2     6     30 #> 18 144       2     1     35 #> 19 168       2     0     36  ##Bin midpoints and boundaries determined by vpc() using bins = \"jenks\" distinct(select(vpc_jenks$data, bin_mid, bin_min, bin_max)) #> Adding missing grouping variables: `strat` #> # A tibble: 11 × 4 #> # Groups:   strat [1] #>    strat bin_mid bin_min bin_max #>    <fct>   <dbl>   <dbl>   <dbl> #>  1 1        1.01     0.5       2 #>  2 1        3        2         5 #>  3 1        5        5         8 #>  4 1       10        8        16 #>  5 1       16       16        24 #>  6 1       24       24        36 #>  7 1       36       36        48 #>  8 1       48       48        72 #>  9 1       72       72        96 #> 10 1       96       96       120 #> 11 1      123.     120       144 vpc_pretty <- vpc(   sim = simout,    obs = filter(simout, SIM == 1),    bins = \"pretty\",    n_bins = \"auto\",    sim_cols = list(dv = \"SIMDV\", idv = \"NTIME\", pred = \"PRED\"),   obs_cols = list(dv = \"OBSDV\", idv = \"NTIME\", pred = \"PRED\"),   pred_corr = TRUE,   pi = c(0.05, 0.95),   ci = c(0.05, 0.95),   show = list(obs_dv = TRUE),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"PRED-corrected Concentration (ng/mL)\" ) +   scale_x_continuous(breaks = seq(0,168,24))  vpc_pretty ##Exact bins in the input data df_nobsbin(data_sad, bin_var = \"NTIME\") #> # A tibble: 19 × 4 #>    NTIME   CMT n_obs n_miss #>    <dbl> <dbl> <int>  <int> #>  1   0       2     0     36 #>  2   0.5     2    34      2 #>  3   1       2    36      0 #>  4   1.5     2    36      0 #>  5   2       2    36      0 #>  6   3       2    36      0 #>  7   4       2    36      0 #>  8   5       2    36      0 #>  9   8       2    36      0 #> 10  12       2    36      0 #> 11  16       2    36      0 #> 12  24       2    36      0 #> 13  36       2    36      0 #> 14  48       2    33      3 #> 15  72       2    29      7 #> 16  96       2    16     20 #> 17 120       2     6     30 #> 18 144       2     1     35 #> 19 168       2     0     36  ##Bin midpoints and boundaries determined by vpc() using bins = \"pretty\" distinct(select(vpc_pretty$data, bin_mid, bin_min, bin_max)) #> Adding missing grouping variables: `strat` #> # A tibble: 9 × 4 #> # Groups:   strat [1] #>   strat bin_mid bin_min bin_max #>   <fct>   <dbl>   <dbl>   <dbl> #> 1 1        3.14       0      10 #> 2 1       14         10      20 #> 3 1       24         20      30 #> 4 1       36         30      40 #> 5 1       48         40      50 #> 6 1       72         70      80 #> 7 1       96         90     100 #> 8 1      120        120     130 #> 9 1      144        140     150 vpc_kmeans <- vpc(   sim = simout,    obs = filter(simout, SIM == 1),    bins = \"kmeans\",    n_bins = \"auto\",    sim_cols = list(dv = \"SIMDV\", idv = \"NTIME\", pred = \"PRED\"),   obs_cols = list(dv = \"OBSDV\", idv = \"NTIME\", pred = \"PRED\"),   pred_corr = TRUE,   pi = c(0.05, 0.95),   ci = c(0.05, 0.95),   show = list(obs_dv = TRUE),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"PRED-corrected Concentration (ng/mL)\" ) +   scale_x_continuous(breaks = seq(0,168,24))  vpc_kmeans ##Exact bins in the input data df_nobsbin(data_sad, bin_var = \"NTIME\") #> # A tibble: 19 × 4 #>    NTIME   CMT n_obs n_miss #>    <dbl> <dbl> <int>  <int> #>  1   0       2     0     36 #>  2   0.5     2    34      2 #>  3   1       2    36      0 #>  4   1.5     2    36      0 #>  5   2       2    36      0 #>  6   3       2    36      0 #>  7   4       2    36      0 #>  8   5       2    36      0 #>  9   8       2    36      0 #> 10  12       2    36      0 #> 11  16       2    36      0 #> 12  24       2    36      0 #> 13  36       2    36      0 #> 14  48       2    33      3 #> 15  72       2    29      7 #> 16  96       2    16     20 #> 17 120       2     6     30 #> 18 144       2     1     35 #> 19 168       2     0     36  ##Bin midpoints and boundaries determined by vpc() using bins = \"kmeans\" distinct(select(vpc_kmeans$data, bin_mid, bin_min, bin_max)) #> Adding missing grouping variables: `strat` #> # A tibble: 11 × 4 #> # Groups:   strat [1] #>    strat bin_mid bin_min bin_max #>    <fct>   <dbl>   <dbl>   <dbl> #>  1 1        1.01    0.5     1.75 #>  2 1        2.5     1.75    3.5  #>  3 1        4.5     3.5     6.5  #>  4 1        8       6.5    10    #>  5 1       14      10      20    #>  6 1       24      20      30    #>  7 1       36      30      42    #>  8 1       48      42      60    #>  9 1       72      60      84    #> 10 1       96      84     108    #> 11 1      123.    108     144 vpc_density <- vpc(   sim = simout,    obs = filter(simout, SIM == 1),    bins = \"density\",    n_bins = length(unique(simout$NTIME)),    sim_cols = list(dv = \"SIMDV\", idv = \"NTIME\", pred = \"PRED\"),   obs_cols = list(dv = \"OBSDV\", idv = \"NTIME\", pred = \"PRED\"),   pred_corr = TRUE,   pi = c(0.05, 0.95),   ci = c(0.05, 0.95),   show = list(obs_dv = TRUE),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"PRED-corrected Concentration (ng/mL)\" ) +   scale_x_continuous(breaks = seq(0,168,24))  vpc_density ##Exact bins in the input data df_nobsbin(data_sad, bin_var = \"NTIME\") #> # A tibble: 19 × 4 #>    NTIME   CMT n_obs n_miss #>    <dbl> <dbl> <int>  <int> #>  1   0       2     0     36 #>  2   0.5     2    34      2 #>  3   1       2    36      0 #>  4   1.5     2    36      0 #>  5   2       2    36      0 #>  6   3       2    36      0 #>  7   4       2    36      0 #>  8   5       2    36      0 #>  9   8       2    36      0 #> 10  12       2    36      0 #> 11  16       2    36      0 #> 12  24       2    36      0 #> 13  36       2    36      0 #> 14  48       2    33      3 #> 15  72       2    29      7 #> 16  96       2    16     20 #> 17 120       2     6     30 #> 18 144       2     1     35 #> 19 168       2     0     36  ##Bin midpoints and boundaries determined by vpc() using bins = \"density\" distinct(select(vpc_density$data, bin_mid, bin_min, bin_max)) #> Adding missing grouping variables: `strat` #> # A tibble: 10 × 4 #> # Groups:   strat [1] #>    strat bin_mid bin_min bin_max #>    <fct>   <dbl>   <dbl>   <dbl> #>  1 1        3.14     0      10.2 #>  2 1       12       10.2    14.4 #>  3 1       16       14.4    20.3 #>  4 1       24       20.3    30.4 #>  5 1       36       30.4    42.3 #>  6 1       48       42.3    60.2 #>  7 1       72       60.2    84.3 #>  8 1       96       84.3   108.  #>  9 1      120      108.    133.  #> 10 1      144      133.    145. vpc_data <- vpc(   sim = simout,    obs = filter(simout, SIM == 1),    bins = \"data\",    sim_cols = list(dv = \"SIMDV\", idv = \"NTIME\", pred = \"PRED\"),   obs_cols = list(dv = \"OBSDV\", idv = \"NTIME\", pred = \"PRED\"),   pred_corr = TRUE,   pi = c(0.05, 0.95),   ci = c(0.05, 0.95),   show = list(obs_dv = TRUE),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"PRED-corrected Concentration (ng/mL)\" ) +   scale_x_continuous(breaks = seq(0,168,24))  vpc_time <- vpc(   sim = simout,    obs = filter(simout, SIM == 1),    bins = \"time\",    sim_cols = list(dv = \"SIMDV\", idv = \"NTIME\", pred = \"PRED\"),   obs_cols = list(dv = \"OBSDV\", idv = \"NTIME\", pred = \"PRED\"),   pred_corr = TRUE,   pi = c(0.05, 0.95),   ci = c(0.05, 0.95),   show = list(obs_dv = TRUE),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"PRED-corrected Concentration (ng/mL)\" ) +   scale_x_continuous(breaks = seq(0,168,24))  vpc_data vpc_time ##Exact bins in the input data df_nobsbin(data_sad, bin_var = \"NTIME\") #> # A tibble: 19 × 4 #>    NTIME   CMT n_obs n_miss #>    <dbl> <dbl> <int>  <int> #>  1   0       2     0     36 #>  2   0.5     2    34      2 #>  3   1       2    36      0 #>  4   1.5     2    36      0 #>  5   2       2    36      0 #>  6   3       2    36      0 #>  7   4       2    36      0 #>  8   5       2    36      0 #>  9   8       2    36      0 #> 10  12       2    36      0 #> 11  16       2    36      0 #> 12  24       2    36      0 #> 13  36       2    36      0 #> 14  48       2    33      3 #> 15  72       2    29      7 #> 16  96       2    16     20 #> 17 120       2     6     30 #> 18 144       2     1     35 #> 19 168       2     0     36  ##Bin midpoints and boundaries determined by vpc() using bins = \"data\" distinct(select(vpc_data$data, bin_mid, bin_min, bin_max)) #> Adding missing grouping variables: `strat` #> # A tibble: 9 × 4 #> # Groups:   strat [1] #>   strat bin_mid bin_min bin_max #>   <fct>   <dbl>   <dbl>   <dbl> #> 1 1        1.25       1      2  #> 2 1        2          2      3  #> 3 1        3.5        3      5  #> 4 1        6.5        5     12  #> 5 1       12         12     16  #> 6 1       20         16     36  #> 7 1       36         36     48  #> 8 1       71.4       48    144. #> 9 1        0.5       NA     NA  ##Bin midpoints and boundaries determined by vpc() using bins = \"time\" distinct(select(vpc_time$data, bin_mid, bin_min, bin_max)) #> Adding missing grouping variables: `strat` #> # A tibble: 7 × 4 #> # Groups:   strat [1] #>   strat bin_mid bin_min bin_max #>   <fct>   <dbl>   <dbl>   <dbl> #> 1 1        5.33   0.357    16.4 #> 2 1       24     16.4      32.4 #> 3 1       41.7   32.4      48.3 #> 4 1       72     64.3      80.2 #> 5 1       96     80.2      96.2 #> 6 1      120    112       128   #> 7 1      144    128       144."},{"path":"https://ryancrass.github.io/pmxhelpr/articles/vpc-exact-bins.html","id":"vpc-plots-with-pmxhelpr","dir":"Articles","previous_headings":"VPC Plot Workflow","what":"VPC Plots with pmxhelpr","title":"VPC Plots with Exact Bins","text":"pmxhelpr function plot_vpc_exactbins() wrapper function vpc(), optimized input datasets containing exact bins. wrapper passes unique exact bins (e.g., nominal times) input dataset bin boundaries addition Inf end vector ensure final exact bin included, rather set boundary. functionality can reproduced using vpc() passing vector unique exact bins bins addition Inf follows: bins = c(sort(unique(simout$NTIME)), Inf)  However, workaround works idv set nominal time variable (idv = \"NTIME) sim_cols obs_cols, removes option plot observationsby actual time (\"TIME\"). plot_vpc_exactbins() gets around limitation plotting observed data separate layer top plot object returned vpc(), including prediction-correction observed points pcvpc = TRUE (also passed along pred_corr argument vpc()).  difference plotting observed prediction-corrected data points \"TIME\" versus \"NTIME\" negligible example dataset, due high concordance \"TIME\" \"NTIME\" example Phase 1 study. However, difference often much larger pooled analyses including later phase clinical studies plotting observed points versus actual time result plot much representative distribution times model training dataset. exploring bins input output datasets using plot_vpc_exactbins(), now see consistent! Huzzah! plot_vpc_exactbins() also contains argument built around function introduced earlier (df_nobsbin()). argument min_bin_count (default = 1) filters exact bins fewer quantifiable observations minimum set argument. Importantly, observed data points small bins still plotted; however, influence calculation summary statistics summary plot elements (shaded intervals, lines). provides greatest fidelity data visualized without introducing visual artifacts due small sample timepoints. Additionally, plot input dataset simout generated using df_mrgsim_replicate, time_vars output_vars match default values, need specify arguments can removed. Furthermore, pi ci arguments specifying match default 90% PI CI vpc() can removed. settingmin_bin_count = 10, summary statistics plotted final two timepoint containing fewer 10 quantifiable observations; however, observations still plotted.  can also pass stratifying variables argument strat_var order facet plots relevant covariate conditions. stratification variables specified strat_var also passed stratify argument vpc(), order facet resulting plots. Currently, one variable can passed argument.","code":"exact_bins <- c(sort(unique(simout$NTIME)), Inf)  vpc_exact_ntime <- vpc(   sim = simout,    obs = filter(simout, SIM == 1),    bins = exact_bins,   sim_cols = list(dv = \"SIMDV\", idv = \"NTIME\", pred = \"PRED\"),   obs_cols = list(dv = \"OBSDV\", idv = \"NTIME\", pred = \"PRED\"),   pred_corr = TRUE,   pi = c(0.05, 0.95),   ci = c(0.05, 0.95),   show = list(obs_dv = TRUE),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"PRED-corrected Concentration (ng/mL)\" )+   scale_x_continuous(breaks = seq(0,168,24))  vpc_exact_ntime vpc_exact <- plot_vpc_exactbins(   sim = simout,    pcvpc = TRUE,   time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),   output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", SIMDV = \"SIMDV\", OBSDV = \"OBSDV\"),   pi = c(0.05, 0.95),   ci = c(0.05, 0.95),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"PRED-corrected Concentration (ng/mL)\" )+   scale_x_continuous(breaks = seq(0,168,24))  vpc_exact ##Exact bins in the input data df_nobsbin(data_sad, bin_var = \"NTIME\") #> # A tibble: 19 × 4 #>    NTIME   CMT n_obs n_miss #>    <dbl> <dbl> <int>  <int> #>  1   0       2     0     36 #>  2   0.5     2    34      2 #>  3   1       2    36      0 #>  4   1.5     2    36      0 #>  5   2       2    36      0 #>  6   3       2    36      0 #>  7   4       2    36      0 #>  8   5       2    36      0 #>  9   8       2    36      0 #> 10  12       2    36      0 #> 11  16       2    36      0 #> 12  24       2    36      0 #> 13  36       2    36      0 #> 14  48       2    33      3 #> 15  72       2    29      7 #> 16  96       2    16     20 #> 17 120       2     6     30 #> 18 144       2     1     35 #> 19 168       2     0     36  ##Bin midpoints and boundaries determined by plot_vpc_exactbins() distinct(select(vpc_exact$data, bin_mid, bin_min, bin_max)) #> Adding missing grouping variables: `strat` #> # A tibble: 17 × 4 #> # Groups:   strat [1] #>    strat bin_mid bin_min bin_max #>    <fct>   <dbl>   <dbl>   <dbl> #>  1 1         0.5     0.5     1   #>  2 1         1       1       1.5 #>  3 1         1.5     1.5     2   #>  4 1         2       2       3   #>  5 1         3       3       4   #>  6 1         4       4       5   #>  7 1         5       5       8   #>  8 1         8       8      12   #>  9 1        12      12      16   #> 10 1        16      16      24   #> 11 1        24      24      36   #> 12 1        36      36      48   #> 13 1        48      48      72   #> 14 1        72      72      96   #> 15 1        96      96     120   #> 16 1       120     120     144   #> 17 1       144     144     Inf vpc_exact_bin_gt10 <- plot_vpc_exactbins(   sim = simout,    pcvpc = TRUE,   min_bin_count = 10,   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"PRED-corrected Concentration (ng/mL)\" ) +   scale_x_continuous(breaks = seq(0,168,24))  vpc_exact_bin_gt10 vpc_exact_food <- plot_vpc_exactbins(   sim = mutate(simout, FOOD_f = factor(FOOD, levels = c(0,1), labels = c(\"Fasted\", \"Fed\"))),    strat_var = \"FOOD_f\",   pcvpc = TRUE,   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"PRED-corrected Concentration (ng/mL)\" ) +   scale_x_continuous(breaks = seq(0,168,24))  vpc_exact_food"},{"path":"https://ryancrass.github.io/pmxhelpr/articles/vpc-obs-quant-blq-cens.html","id":"exploratory-data-analysis","dir":"Articles","previous_headings":"","what":"Exploratory Data Analysis","title":"VPC Plots with BLQ Censoring","text":"Next let’s explore input dataset data_sad. dataset generated via simulation mrgsolve model internal pmxhelpr package. can take quick look dataset using glimpse() dplyr. Let’s visualize data. visualization, leverage functionality plot_dvtime visualize data. First, derive factor variable DOSE pass color aesthetic. Now let’s plot data using ODV colored Dose (mg) faceted PART.  concentration-time profiles increase dose potential impact censoring LLOQ late terminal phase. assess potential impact BLQ censoring, set loq_method = 2 plot_dvtime, imputes BLQ data 1/2 x LLOQ. Imputing concentrations lower limit quantification 1/2 x LLOQ normalizes late terminal phase concentration-time profile. suggests artifact late terminal phase due censoring observations LLOQ, impacts lower doses higher doses.  Indeed, pharmacokinetic data generally treated continuous log-normally distributed data, reality distribution truncated lower limit quantification assays used bioanalysis. Therefore, whenever evaluating concentration-time plots, hould keep mind assay limitations potential impact visual trends. examine , let’s visualize two different concentrations variables plot_data object single dose: ODV: Original dependent variable based source data. Data LLOQ censored set missing NA. DV: Derived dependent variable data LLOQ set 0.5 x LLOQ. focus 100 mg dose, included Part1-SAD Part2-FE, appears display visual artifact potentially due censoring LLOQ.  can see plots central tendency late terminal phase influenced censoring LLOQ. leads visual artifact, may sometimes appear like another log-linear slope. exact pattern impact depend dose intensity, assay sensitivity, study sampling scheme. relative impact unobserved portion distribution concentration can visualized histograms facetted nominal sampling time. distributions pooled across Part 1-SAD Part 2-FE 100 mg histograms.  study protocol included sampling 72 hours, impact censoring assay LLOQ negligible single 100 mg dose, regardless food condition. However, large portion distribution concentrations BLQ later timepoints one week duration sampling. expected frequency censored data LLOQ increase increasing time dose administration. Additionally, expect frequency censored data LLOQ decrease increasing dose intensity. can visualize summarizing fraction samples missing due assay sensitivity (MDV=1) timepoint, dose, study part.  summary, observed patters BLQ data example dataset anticipated early phase clinical study. - increasing frequency BLQ data increasing time - decreasing frequency BLQ data increasing dose BLQ data often ignored (.e., set missing; M1 method) population PK model development. unlikely introduce appreciable bias model parameter estimation, provided absolute frequency BLQ data low (e.g., <10-20%) pattern BLQ censoring line expectations dose time. However, just BLQ censoring introduced artifact explortory plots concentration time, handling BLQ data VPCs may impact interpretation graphical model diagnostics.","code":"glimpse(data_sad) #> Rows: 720 #> Columns: 23 #> $ LINE    <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,… #> $ ID      <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,… #> $ TIME    <dbl> 0.00, 0.00, 0.48, 0.81, 1.49, 2.11, 3.05, 4.14, 5.14, 7.81, 12… #> $ NTIME   <dbl> 0.0, 0.0, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0, 5.0, 8.0, 12.0, 16.0, … #> $ NDAY    <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 4, 5, 6, 7, 8, 1,… #> $ DOSE    <dbl> 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10… #> $ AMT     <dbl> NA, 10, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ EVID    <dbl> 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… #> $ ODV     <dbl> NA, NA, NA, 2.02, 4.02, 3.50, 7.18, 9.31, 12.46, 13.43, 12.11,… #> $ LDV     <dbl> NA, NA, NA, 0.7031, 1.3913, 1.2528, 1.9713, 2.2311, 2.5225, 2.… #> $ CMT     <dbl> 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… #> $ MDV     <dbl> 1, NA, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1… #> $ BLQ     <dbl> -1, NA, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, … #> $ LLOQ    <dbl> 1, NA, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… #> $ FOOD    <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… #> $ SEXF    <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,… #> $ RACE    <dbl> 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1,… #> $ AGEBL   <int> 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25… #> $ WTBL    <dbl> 82.1, 82.1, 82.1, 82.1, 82.1, 82.1, 82.1, 82.1, 82.1, 82.1, 82… #> $ SCRBL   <dbl> 0.87, 0.87, 0.87, 0.87, 0.87, 0.87, 0.87, 0.87, 0.87, 0.87, 0.… #> $ CRCLBL  <dbl> 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 12… #> $ USUBJID <chr> \"STUDYNUM-SITENUM-1\", \"STUDYNUM-SITENUM-1\", \"STUDYNUM-SITENUM-… #> $ PART    <chr> \"Part 1-SAD\", \"Part 1-SAD\", \"Part 1-SAD\", \"Part 1-SAD\", \"Part … plot_data <- data_sad %>%    filter(EVID == 0) %>%    mutate(`Dose (mg)` = factor(DOSE)) plot_dvtime(plot_data, dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\",               ylab = \"Concentration (ng/mL)\", xlab = \"Time (hours\") +   scale_x_continuous(breaks = seq(0,168,24))+   scale_y_log10()+   facet_wrap(~PART)+   theme_bw() plot_dvtime(plot_data, dv_var = c(DV = \"ODV\"), col_var = \"Dose (mg)\", loq_method = 2,              ylab = \"Concentration (ng/mL)\", xlab = \"Time (hours\") +   scale_x_continuous(breaks = seq(0,168,24))+   scale_y_log10()+   facet_wrap(~PART)+   theme_bw() plot_data100 <- plot_data %>%    filter(DOSE == 100) %>%    mutate(DV = ifelse(BLQ == 0, ODV, LLOQ/2))  ggplot(aes(x = TIME, y = ODV), data = plot_data100)+   geom_point(shape = 1, alpha = 0.5)+   stat_summary(fun = \"mean\", geom = \"point\",                 aes(x = NTIME, y = ODV, col = \"DV (>LLOQ)\"), inherit.aes = FALSE) +   stat_summary(fun = \"mean\", geom = \"line\",                 aes(x = NTIME, y = ODV, col = \"DV (>LLOQ)\"), inherit.aes = FALSE) +   stat_summary(fun = \"mean\", geom = \"point\",                 aes(x = NTIME, y = DV, col = \"DV (>0.5LLOQ)\"), inherit.aes = FALSE) +   stat_summary(fun = \"mean\", geom = \"line\",                 aes(x = NTIME, y = DV, col = \"DV (>0.5LLOQ)\"), inherit.aes = FALSE) +   geom_hline(yintercept = unique(plot_data$LLOQ), linetype = \"dashed\")+   scale_x_continuous(breaks = seq(0,168,24))+   scale_y_log10()+   scale_color_manual(name = \"Data Handling\",                       breaks = c(\"DV (>LLOQ)\", \"DV (>0.5LLOQ)\"),                       values = c(\"DV (>LLOQ)\" = \"#440154FF\", \"DV (>0.5LLOQ)\" = \"#21908CFF\"))+   facet_wrap(~PART)+   labs(y = \"Concentration (ng/mL)\", x = \"Time Since Dose Administration (hours)\")+   theme_bw() ggplot(aes(x = DV), data = filter(plot_data100, NTIME %in% seq(24,144,24), DOSE == 100))+   geom_histogram()+   geom_vline(xintercept = unique(plot_data$LLOQ), linetype = \"dashed\", color = \"red\")+   scale_x_log10()+   facet_wrap(~NTIME)+   labs(y = \"Density\", x = \"Concentration (ng/mL)\")+   theme_bw() plot_data_sumblq <- plot_data %>%    group_by(DOSE, `Dose (mg)`,NTIME, PART) %>%    summarize(`Fraction BLQ`= mean(MDV)) %>%    ungroup()  ggplot(aes(x = NTIME, y = `Fraction BLQ`, col = `Dose (mg)`), data = plot_data_sumblq)+   geom_line()+   scale_x_continuous(breaks = seq(0,168,24))+   facet_wrap(~PART)+   labs(y = \"Fraction of Samples BLQ\", x = \"Nominal Time Since Dose Administration (hours)\")+   theme_bw()"},{"path":"https://ryancrass.github.io/pmxhelpr/articles/vpc-obs-quant-blq-cens.html","id":"vpc-plots-accounting-for-blq-censoring","dir":"Articles","previous_headings":"","what":"VPC Plots Accounting for BLQ Censoring","title":"VPC Plots with BLQ Censoring","text":"Lets run simulation generate VPC plots demonstrate impact different approaches BLQ handling visual assessment adequacy model fit true underlying PK profile. Let’s start focusing evaluating model fit 100 mg dose level exploring across Part1-SAD Part2-FE. two potential approaches proccessing plotting VPC: Exclude BLQ: remove missing observations (MDV=1) observed simulated data Censor Observed Quantiles: set quantiles observed data NA, sample representing quantile observed BLQ (MDV=1) bin. Let’s plot using default arguments plot_vpc_exactbins(). default behavior Exclude BLQ, filters MDV=1. observed median appears consistent exploratory concentration-time profiles generated earlier excluding data lower limit quantification (ODV). Notice increasing trend observed quantiles later timelines coincides completely overlapping simulated confidence intervals quantiles. due decreasing sample size time due exclusion timeplints MDV=1. Let’s instead try specifying new argument loq plot_vpc_exactbins(). loq numeric value lower limit quantification units dependent variable. primarily serves alias lloq vpc::vpc(), leveraging BLQ handling functionality already built package. Now see red horizontal line depicting LLOQ (1 ng/mL). Notice also increase y-axis range, change shape observed quantiles, greater resolution separation confidence intervals. Specifying loq assumes input dataset plot, sim, MDV=1 represents BLQ samples (e.g., EVID = 0). MDV variable sim set zero (0) timepoints included. calculation summary statistics observed data, quantiles calculated across data per bin taken NA quantile observations loq. calcluation summary statistics simulated data, simulated confidence intervals based data without censoring, representative model-predicted “true” underlying PK profile absence real-world assay limitations. Specifying loq preferred method plotting VPC diagnostics pmexhelpr package.default method due --common case assay LLOQ known analyst. Additionally, method accounting censoring data LLOQ specifying loq argument applied Visual Predictive Checks (pcvpc = FALSE) applied Prediction-corrected Visual Predictive Checks (pcvpc = TRUE). Ifloq specified withpcvpc = TRUE, error message print vpc::vpc().","code":"model <- model_mread_load(\"model\") #> Building model_cpp ... done.  simout <- df_mrgsim_replicate(data = data_sad, model = model,replicates = 100,                       time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),                      output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", DV = \"ODV\"),                      num_vars = c(\"CMT\", \"BLQ\", \"LLOQ\", \"EVID\", \"MDV\", \"DOSE\", \"FOOD\"),                      char_vars = c(\"PART\"),                      obsonly = TRUE) sim100 <- simout %>%    filter(DOSE == 100) vpc_blq_drop <- plot_vpc_exactbins(   sim = sim100,    time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),   output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", SIMDV = \"SIMDV\", OBSDV = \"OBSDV\"),   pi = c(0.05, 0.95),   ci = c(0.05, 0.95),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"Concentration (ng/mL)\",   strat_var = \"PART\" ) +   scale_x_continuous(breaks = seq(0,168,24))  vpc_blq_drop vpc_blq_qobs_cens <- plot_vpc_exactbins(   sim = sim100,    time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),   output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", SIMDV = \"SIMDV\", OBSDV = \"OBSDV\"),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"Concentration (ng/mL)\",   strat_var = \"PART\",   loq = 1 ) +   scale_x_continuous(breaks = seq(0,168,24))  vpc_blq_qobs_cens vpc_pc <- plot_vpc_exactbins(   sim = simout,    time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),   output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", SIMDV = \"SIMDV\", OBSDV = \"OBSDV\"),   pi = c(0.05, 0.95),   ci = c(0.05, 0.95),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"Concentration (ng/mL)\",   pcvpc = TRUE,   loq = 1 ) +   scale_x_continuous(breaks = seq(0,168,24)) #> Joining with `by = join_by(CMT, NTIME)` #> Joining with `by = join_by(CMT, NTIME)` #> Prediction-correction cannot be used together with censored data (<LLOQ or #> >ULOQ). VPC plot will be shown for non-censored data only!  vpc_pc"},{"path":"https://ryancrass.github.io/pmxhelpr/articles/vpc-plot-aesthetics.html","id":"default-aesthetics","dir":"Articles","previous_headings":"","what":"Default Aesthetics","title":"VPC Plot Aesthetics","text":"Now let’s plot data together prediction-corrected VPC (pcVPC). single dose administration dataset, thus able pool across doses food conditions prediction-correction. set min_bin_count = 5 avoid simulated intervals extending final timepoint single observation.","code":"vpc_pc <- plot_vpc_exactbins(   sim = simout,    time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),   output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", SIMDV = \"SIMDV\", OBSDV = \"OBSDV\"),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"Concentration (ng/mL)\",   pcvpc = TRUE,   min_bin_count = 5 ) +   scale_x_continuous(breaks = seq(0,168,24)) #> Joining with `by = join_by(CMT, NTIME)` #> Joining with `by = join_by(CMT, NTIME)`  vpc_pc"},{"path":"https://ryancrass.github.io/pmxhelpr/articles/vpc-plot-aesthetics.html","id":"vpc-plot-aesthetics","dir":"Articles","previous_headings":"","what":"VPC Plot Aesthetics","title":"VPC Plot Aesthetics","text":"default elements shown plot inherited vpc(). shown argument can provided plot_vpc_exactbins() passed show argument vpc(). default follows: components list correspond following vpc plot elements: - Observed points: obs_dv = Observed quantiles: obs_ci - Simulated inter-quantile range: pi - Simulated inter-quantile area: pi_as_area - Simulated Quantile CI: pi_ci - Observed Median: obs_median - Simulated Median: sim_median - Simulated Median CI: sim_median_ci One elements updated defaults can passed list argument shown. elements specified shown inherit defaults. example, let’s say want remove observed data points plot better visualize observed quntile lines relative corresponding simulated confidence intervals. can follows.  also take one step look median simulated confidence interval median, closely interrogate central tendency. common VPC strata observations, leading inadrquate sample size discriminate confidence intervals median extremes. common scenario evaluating VPC plots stratified individual study arms early phase trials.  Similarly, default aesthetics plot inherited defaults vpc package, can viewed running new_vpc_theme() arguments. Now, suppose want change default aesthetics VPC plot, without changing shown. can accomplished passing named list elements update function new_vpc_theme(). named list object generated function can passed theme argument vpc_plot_exactbins, also alias vpc_theme argument vpc(). Let’s say prefer classical VPC color schema, based basic red-blue-green color brewer. make following changes: - Observed points blue - Observed median simulated 90% CI median red - Observed 5th 95th simulated 90% CI 5th 95th blue Now, let’s take look plot prior plot new color schema.  nice; however, like grey background prefer major y-axis grid lines without x-axis grid lines. Conveniently, can just add theme() elements top plot object using standard ggplot2 approach.","code":"shown_list <- list(obs_dv = TRUE, obs_ci = TRUE,                    pi = FALSE, pi_as_area = FALSE, pi_ci = TRUE,                    obs_median = TRUE, sim_median =FALSE, sim_median_ci = TRUE) vpc_pc_noobs <- plot_vpc_exactbins(   sim = simout,    time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),   output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", SIMDV = \"SIMDV\", OBSDV = \"OBSDV\"),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"Concentration (ng/mL)\",   pcvpc = TRUE,   min_bin_count = 5,   shown = list(obs_dv = FALSE) ) +   scale_x_continuous(breaks = seq(0,168,24)) #> Joining with `by = join_by(CMT, NTIME)` #> Joining with `by = join_by(CMT, NTIME)`  vpc_pc_noobs vpc_pc_noobs_medonly <- plot_vpc_exactbins(   sim = simout,    time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),   output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", SIMDV = \"SIMDV\", OBSDV = \"OBSDV\"),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"Concentration (ng/mL)\",   pcvpc = TRUE,   min_bin_count = 5,   shown = list(obs_dv = FALSE, obs_ci = FALSE, pi_ci = FALSE) ) +   scale_x_continuous(breaks = seq(0,168,24)) #> Joining with `by = join_by(CMT, NTIME)` #> Joining with `by = join_by(CMT, NTIME)`  vpc_pc_noobs_medonly vpc_theme_list <- new_vpc_theme() print(vpc_theme_list) #> $obs_color #> [1] \"#000000\" #>  #> $obs_size #> [1] 1 #>  #> $obs_median_color #> [1] \"#000000\" #>  #> $obs_median_linetype #> [1] \"solid\" #>  #> $obs_median_size #> [1] 1 #>  #> $obs_alpha #> [1] 0.7 #>  #> $obs_shape #> [1] 1 #>  #> $obs_ci_color #> [1] \"#000000\" #>  #> $obs_ci_linetype #> [1] \"dashed\" #>  #> $obs_ci_fill #> [1] \"#80808033\" #>  #> $obs_ci_size #> [1] 0.5 #>  #> $sim_pi_fill #> [1] \"#3388cc\" #>  #> $sim_pi_alpha #> [1] 0.15 #>  #> $sim_pi_color #> [1] \"#000000\" #>  #> $sim_pi_linetype #> [1] \"dotted\" #>  #> $sim_pi_size #> [1] 1 #>  #> $sim_median_fill #> [1] \"#3388cc\" #>  #> $sim_median_alpha #> [1] 0.3 #>  #> $sim_median_color #> [1] \"#000000\" #>  #> $sim_median_linetype #> [1] \"dashed\" #>  #> $sim_median_size #> [1] 1 #>  #> $bin_separators_color #> [1] \"#000000\" #>  #> $loq_color #> [1] \"#990000\" #>  #> attr(,\"class\") #> [1] \"vpc_theme\" vpc_theme <- new_vpc_theme(   list(   obs_color = rgb(0,0,1),      obs_median_color = rgb(1,0,0),   obs_ci_color = rgb(0,0,1),      sim_median_fill = rgb(1,0,0),   sim_pi_fill = rgb(0,0,1)   ) ) vpc_pc_new <- plot_vpc_exactbins(   sim = simout,    time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),   output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", SIMDV = \"SIMDV\", OBSDV = \"OBSDV\"),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"Concentration (ng/mL)\",   pcvpc = TRUE,   theme = vpc_theme,   min_bin_count = 5 ) +   scale_x_continuous(breaks = seq(0,168,24)) #> Joining with `by = join_by(CMT, NTIME)` #> Joining with `by = join_by(CMT, NTIME)`  vpc_pc_new vpc_pc_new2 <- plot_vpc_exactbins(   sim = simout,    time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),   output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", SIMDV = \"SIMDV\", OBSDV = \"OBSDV\"),   log_y = TRUE,   xlab = \"Time (hours)\",   ylab = \"Concentration (ng/mL)\",   pcvpc = TRUE,   min_bin_count = 5,   theme = vpc_theme ) +   scale_x_continuous(breaks = seq(0,168,24)) +   theme(panel.background = element_rect(fill = \"white\", linewidth = 0.5, color = \"black\"),         panel.grid.minor.y = element_blank(),          panel.grid.minor.x = element_blank(),          panel.grid.major.x = element_blank()) #> Joining with `by = join_by(CMT, NTIME)` #> Joining with `by = join_by(CMT, NTIME)`  vpc_pc_new2"},{"path":"https://ryancrass.github.io/pmxhelpr/articles/vpc-plot-aesthetics.html","id":"vpc-plot-legends","dir":"Articles","previous_headings":"","what":"VPC Plot Legends","title":"VPC Plot Aesthetics","text":"Okay, now gotten plot aesthetics want ; however, one element may like include figure make easily interpreted isolation - legend. pmxhelpr provides useful helper function purpose, plot_legend(). arguments plot_legend() follows: - ci simulated confidence interval plotted. Default c(0.05, 0.95). - pi prediction intervals plotted. Default c(0.05, 0.95). - lloq label lower limit quantification plot legend. - update list containing plot elements updated. Default set vpc::new_vpc_theme(). - shown Named list logicals specifying layers include plot. obtain legend plot using default aesthetics, simply run plot_legend() without arguments specified.  Now ggplot object legend first plot! generate one second plot updated aesthetics, let’s pass named list object (vpc_theme) update argument.  Okay, now legend plot objects, let’s combine VPC plot objects single plot object patchwork package.","code":"vpc_pc_legend <- plot_legend() vpc_pc_legend vpc_pc_new_legend <- plot_legend(update = vpc_theme) vpc_pc_new_legend vpc_pc_wleg <- vpc_pc + vpc_pc_legend + plot_layout(heights = c(2.5,1)) vpc_pc_wleg vpc_pc_new_wleg <- vpc_pc_new2 + vpc_pc_new_legend + plot_layout(heights = c(2.5,1)) vpc_pc_new_wleg"},{"path":"https://ryancrass.github.io/pmxhelpr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ryan Crass. Author, maintainer, copyright holder.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ryan L. Crass (2024). pmxhelpr: R package helper functions pharmacometrics applications. https://github.com/ryancrass/pmxhelpr.","code":"@Manual{,   title = {pmxhelpr: an R package of helper functions for pharmacometrics applications},   author = {{Ryan L. Crass}},   address = {Ann Arbor, Michigan, United States},   year = {2024},   url = {https://github.com/ryancrass/pmxhelpr}, }"},{"path":"https://ryancrass.github.io/pmxhelpr/index.html","id":"pmxhelpr-","dir":"","previous_headings":"","what":"Helper Functions for Pharmacometrics","title":"Helper Functions for Pharmacometrics","text":"goal pmxhelpr make pharmacometrics workflows standardized, efficient, reproducible. package provides helper wrapper functions common steps pharmacometrics analysis workflow, exploratory data analysis, model development, model evaluation, model application.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Helper Functions for Pharmacometrics","text":"can install development version pmxhelpr GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"ryancrass/pmxhelpr\")"},{"path":"https://ryancrass.github.io/pmxhelpr/index.html","id":"function-naming-conventions","dir":"","previous_headings":"","what":"Function Naming Conventions","title":"Helper Functions for Pharmacometrics","text":"Functions package use following naming conventions: model_mread_load() wraps mrgsolve::mread_cache() read internal package model files returning mrgmod object. df_mrgsim_addpred() wraps mrgsolve::mrgsim() including mrgsolve::zero_re() add population predictions (PRED) input data returning data.frame. df_mrgsim_replicate() wraps mrgsolve::mrgsim() replicate input data returning data.frame. plot_vpc_exactbins() wraps vpc::vpc() generate VPC plot using exact time bins returning ggplot object. df_nobsbin returns summary data.frame counts number missing non-missing observations per bin. df_pcdv returns data.frame containing prediction-corrected dependent variable. plot_legend returns ggplot object containing legend VPC plot generated using plot_vpc_exactbins","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/index.html","id":"example-visual-predictive-check-workflow","dir":"","previous_headings":"","what":"Example Visual Predictive Check Workflow","title":"Helper Functions for Pharmacometrics","text":"basic example illustrates simple VPC workflow using pmxhelpr:","code":"library(pmxhelpr) library(dplyr) library(ggplot2) library(mrgsolve) library(vpc) library(patchwork) library(withr)  #Read internal analysis-ready dataset for an example Phase 1 study glimpse(data_sad)  #Read internal mrgsolve model file model <- model_mread_load(\"model\")  #Simulated replicates of the dataset using mrgsim  simout <- df_mrgsim_replicate(data = data_sad, model = model,replicates = 100,                               output_vars = c(DV = \"ODV\"),                               num_vars = c(\"CMT\", \"LLOQ\", \"EVID\", \"MDV\", \"WTBL\", \"FOOD\"),                               char_vars = c(\"USUBJID\", \"PART\")) glimpse(simout)  #Plot output in a Prediction-corrected Visual Predictive Check (VPC)   #Exact nominal time bins present in data_sad (\"NTIME\") are used to plot summary statistics   #Actual time (\"TIME\") is used to plot observed data points, which are also prediction-corrected if pcvpc=TRUE   #LLOQ in the dataset is 1 ng/mL    plot_obj_food <- plot_vpc_exactbins(   sim = mutate(simout, FOOD_f = factor(FOOD, levels = c(0,1), labels = c(\"Fasted\", \"Fed\"))),    strat_vars = \"FOOD_f\",   pcvpc = TRUE,   time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),   output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", SIMDV = \"SIMDV\", OBSDV = \"OBSDV\"),   pi = c(0.05, 0.95),   ci = c(0.05, 0.95),   loq = 1,   log_y = TRUE )  plot_obj_food  #Add Legend plot_obj_leg <- plot_legend(pi = c(0.05, 0.95), ci = c(0.05, 0.95)) plot_obj_leg  plot_obj_food_wleg <- plot_obj_food + plot_obj_leg + plot_layout(heights = c(2,1)) plot_obj_food_wleg"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/data_sad.html","id":null,"dir":"Reference","previous_headings":"","what":"Example NONMEM Analysis-Ready Dataset for PK Modeling of a Single Ascending Dose Study — data_sad","title":"Example NONMEM Analysis-Ready Dataset for PK Modeling of a Single Ascending Dose Study — data_sad","text":"Example NONMEM Analysis-Ready Dataset PK Modeling Single Ascending Dose Study","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/data_sad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example NONMEM Analysis-Ready Dataset for PK Modeling of a Single Ascending Dose Study — data_sad","text":"","code":"data_sad"},{"path":[]},{"path":"https://ryancrass.github.io/pmxhelpr/reference/data_sad.html","id":"data-frame-a-data-frame-with-rows-and-columns-","dir":"Reference","previous_headings":"","what":"data.frame a data frame with 720 rows and 23 columns:","title":"Example NONMEM Analysis-Ready Dataset for PK Modeling of a Single Ascending Dose Study — data_sad","text":"LINE Line number ID NONMEM subject identifier TIME Actual time since first dose (units: hours) NTIME Nominal time since first dose (units: hours) NDAY Nominal study day (units: days) DOSE Nominal dose assignment (units: mg) AMT Actual dose amount administrered (units: mg) EVID NONMEM-specific event identifier ODV Dependent variable original units (units: ng/mL) LDV Log-transformed dependent variable (units: log(ng/mL)) CMT NONMEM-specific compartment variable (values: 1=dose, 2=plasma concentration) MDV NONMEM-specific missing dependent variable indicator BLQ Concentration lower limit quantification flag (values: -1=pre-dose BLQ, 0=BLQ, 1=post-dose BLQ) LLOQ Lower limit quantification (units: ng/mL) FOOD Co-administration food (values: 0=fasted, 1=high-fat meal) SEXF Subject female sex (values: 0=male, 1=female) RACE Subject race (units: hours) AGEBL Subject age baseline (units: years) WTBL Subject body weight baseline (units:kg) SCRBL Subject serum creatinine baseline (units: g/dL) CRCLBL Subject creatinine clearance baseline (units: mL/min) USUBJID Study subject identifier PART Study part","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/data_sad.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example NONMEM Analysis-Ready Dataset for PK Modeling of a Single Ascending Dose Study — data_sad","text":"simulated","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_addpred.html","id":null,"dir":"Reference","previous_headings":"","what":"Add population predictions (PRED) to a data.frame — df_addpred","title":"Add population predictions (PRED) to a data.frame — df_addpred","text":"df_addpred() wrapper function mrgsolve::mrgsim_df() mrgsolve::zero_re() returns data.frame addition new variable (PRED).","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_addpred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add population predictions (PRED) to a data.frame — df_addpred","text":"","code":"df_addpred(data, model, output_var = \"IPRED\", ...)"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_addpred.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add population predictions (PRED) to a data.frame — df_addpred","text":"data Input dataset. model mrgsolve model object. output_var Name output model captured PRED removing random effects mrgsolve::zero_re().Default \"IPRED\". ... Additional arguments passed mrgsolve::mrgsim_df().","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_addpred.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add population predictions (PRED) to a data.frame — df_addpred","text":"data.frame number rows data additional numeric variable PRED.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_addpred.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add population predictions (PRED) to a data.frame — df_addpred","text":"","code":"model <- model_mread_load(model = \"model\") #> Building model_cpp ...  #> done. data <- df_addpred(data = data_sad, model = model)"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_mrgsim_replicate.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute a visual predictive check (VPC) simulation using mrgsolve — df_mrgsim_replicate","title":"Execute a visual predictive check (VPC) simulation using mrgsolve — df_mrgsim_replicate","text":"df_mrgsim_replicate() wrapper function mrgsolve::mrgsim_df() returns data.frame containing replicates iterations data","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_mrgsim_replicate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute a visual predictive check (VPC) simulation using mrgsolve — df_mrgsim_replicate","text":"","code":"df_mrgsim_replicate(   data,   model,   replicates,   time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),   output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", DV = \"DV\"),   num_vars = NULL,   char_vars = NULL,   irep_name = \"SIM\",   seed = 123456789,   ... )"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_mrgsim_replicate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute a visual predictive check (VPC) simulation using mrgsolve — df_mrgsim_replicate","text":"data Input dataset. Must contain required variables mrgsim_df() handled arguments. model mrgsolve model object. replicates Number replicates. Either integer, something coercible integer. time_vars Names actual nominal time variables. Must named character vector. Defaults \"TIME\" \"NTIME\". output_vars Names model outputs model. Must named character vector. Defaults \"PRED\", \"IPRED\", \"DV\". Currently \"IPRED\" \"DV\" required model@capture. num_vars Numeric variables data simulation output recover. Must character vector variable names simulation output carry_out return output. Defaults \"CMT\", \"EVID\", \"MDV\", \"NTIME\". char_vars Character variables data simulation output recover. Must character vector variable names simulation output recover return output. irep_name Name replicate variable data. Must string. Default \"SIM\". seed Random seed. Default 123456789. ... Additional arguments passed mrgsolve::mrgsim_df().","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_mrgsim_replicate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Execute a visual predictive check (VPC) simulation using mrgsolve — df_mrgsim_replicate","text":"data.frame data x replicates rows (unless obsonly=TRUE) output variables output_vars, num_vars, char_vars.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_mrgsim_replicate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Execute a visual predictive check (VPC) simulation using mrgsolve — df_mrgsim_replicate","text":"","code":"model <- model_mread_load(model = \"model\") #> Loading model from cache. simout <- df_mrgsim_replicate(data = data_sad, model = model, replicates = 100, output_vars = c(DV = \"ODV\"), num_vars = c(\"CMT\", \"LLOQ\", \"EVID\", \"MDV\", \"WTBL\", \"FOOD\"), char_vars = c(\"USUBJID\", \"PART\"), irep_name = \"SIM\")"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_nobsbin.html","id":null,"dir":"Reference","previous_headings":"","what":"Count the non-missing observations in each exact bin — df_nobsbin","title":"Count the non-missing observations in each exact bin — df_nobsbin","text":"df_nobsbin() helper function count number missing non-missing observations exact bins.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_nobsbin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count the non-missing observations in each exact bin — df_nobsbin","text":"","code":"df_nobsbin(data, bin_var = \"NTIME\", strat_vars = NULL)"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_nobsbin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count the non-missing observations in each exact bin — df_nobsbin","text":"data Input dataset. bin_var Binning variable. Default \"NTIME\". strat_vars Stratifying variables. Must character vector.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_nobsbin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count the non-missing observations in each exact bin — df_nobsbin","text":"data.frame containing one row per unique combination bin_var strat_vars new variables n_obs, count non-missing observations, n_miss, count missing observations.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_nobsbin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count the non-missing observations in each exact bin — df_nobsbin","text":"","code":"df_nobsbin(data_sad) #> # A tibble: 19 × 4 #>    NTIME   CMT n_obs n_miss #>    <dbl> <dbl> <int>  <int> #>  1   0       2     0     36 #>  2   0.5     2    34      2 #>  3   1       2    36      0 #>  4   1.5     2    36      0 #>  5   2       2    36      0 #>  6   3       2    36      0 #>  7   4       2    36      0 #>  8   5       2    36      0 #>  9   8       2    36      0 #> 10  12       2    36      0 #> 11  16       2    36      0 #> 12  24       2    36      0 #> 13  36       2    36      0 #> 14  48       2    33      3 #> 15  72       2    29      7 #> 16  96       2    16     20 #> 17 120       2     6     30 #> 18 144       2     1     35 #> 19 168       2     0     36"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_pcdv.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform prediction-correction of the dependent variable — df_pcdv","title":"Perform prediction-correction of the dependent variable — df_pcdv","text":"df_pcdv helper function perform prediction-correction observed simulated depedent variables.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_pcdv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform prediction-correction of the dependent variable — df_pcdv","text":"","code":"df_pcdv(   data,   bin_var = \"NTIME\",   strat_vars = NULL,   output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", DV = \"DV\"),   lower_bound = 0 )"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_pcdv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform prediction-correction of the dependent variable — df_pcdv","text":"data Input dataset bin_var Exact binning variable. Default \"NTIME\". strat_vars Stratifying variables. Default \"CMT\". output_vars Names model outputs model. Must named character vector. Defaults \"PRED\", \"IPRED\", \"DV\". Currently \"IPRED\" \"DV\" required model@capture. lower_bound Lower bound dependent variable prediction correction. Default 0.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_pcdv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform prediction-correction of the dependent variable — df_pcdv","text":"data.frame containing one row per unique combination bin_var strat_vars new variable PCDV containing prediction-corrected observations.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/df_pcdv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform prediction-correction of the dependent variable — df_pcdv","text":"","code":"model <- model_mread_load(model = \"model\") #> Loading model from cache. data <- df_addpred(data_sad, model) simout <- df_pcdv(data, output_vars = c(DV = \"ODV\", PRED = \"PRED\"))"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/model_mread_load.html","id":null,"dir":"Reference","previous_headings":"","what":"Load an mrgsolve model file from the internal model library — model_mread_load","title":"Load an mrgsolve model file from the internal model library — model_mread_load","text":"model_mread_load() returns mrgsolve model object internal model library pmxhelpr","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/model_mread_load.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load an mrgsolve model file from the internal model library — model_mread_load","text":"","code":"model_mread_load(model, ...)"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/model_mread_load.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load an mrgsolve model file from the internal model library — model_mread_load","text":"model Model file name. Must string. ... Additional arguments passed mrgsolve::mread_cache().","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/model_mread_load.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load an mrgsolve model file from the internal model library — model_mread_load","text":"mrgsolve model object.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/model_mread_load.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load an mrgsolve model file from the internal model library — model_mread_load","text":"","code":"model <- model_mread_load(\"model\") #> Loading model from cache."},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_dvtime.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a dependent variable versus time — plot_dvtime","title":"Plot a dependent variable versus time — plot_dvtime","text":"Plot dependent variable versus time","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_dvtime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a dependent variable versus time — plot_dvtime","text":"","code":"plot_dvtime(   data,   dv_var = c(DV = \"DV\"),   time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),   col_var = NULL,   loq = NULL,   loq_method = 0,   cent = \"mean\",   obs_dv = TRUE,   ind_dv = FALSE,   dosenorm = FALSE,   cfb = FALSE,   ylab = \"Concentration\",   xlab = \"Time\",   log_y = FALSE,   show_caption = TRUE )"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_dvtime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a dependent variable versus time — plot_dvtime","text":"data Input dataset. Must contain variables: \"ID\", \"DV\" \"MDV\". dv_var Character string dependent variable. Default \"DV\". time_vars Names actual nominal time variables. Must named character vector. Defaults \"TIME\" \"NTIME\". col_var Character string name variable map color aesthetic. loq Numeric value lower limit quantification (LLOQ) assay. Must coercible numeric specified. Can NULL variable LLOQ present data Specifying argument implies DVis missing data < LLOQ. loq_method Method handling data lower limit quantification (BLQ) plot. Options : + 0 : handling. Plot input dataset DV vs TIME . (default) + 1 : Impute BLQ data TIME <= 0 0 BLQ data TIME > 0 1/2 x loq. Useful plotting concentration-time data data BLQ linear scale + 2 : Impute BLQ data TIME <= 0 1/2 x loq BLQ data TIME > 0 1/2 x loq. Useful plotting concentration-time data data BLQ log scale 0 displayed cent Character string specifying central tendency measure plot. Options : Mean : \"mean\" (default) Mean +/- Standard Deviation: \"mean_sdl\" Median : \"median\" None: \"none\" obs_dv Logical indicating observed data points shown. Default TRUE. ind_dv Logical indiciating observed data points shoudld connected within individual (.e., spaghetti plot). Default FALSE. dosenorm logical indicating observed data points dose normalized. Default FALSE, Requires variable DOSE present data cfb Logical indicating dependent variable change baseline. Plots reference line y = 0. Default FALSE. ylab Character string specifing y-axis label: Default \"Concentration\". xlab Character string specfing x-axis label: Default \"Time\". log_y Logical indicator log10 transformation y-axis. show_caption Logical indicating caption show describing data plotted","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_dvtime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a dependent variable versus time — plot_dvtime","text":"ggplot2 plot object","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_dvtime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a dependent variable versus time — plot_dvtime","text":"","code":"data <- dplyr::mutate(data_sad, Dose = factor(DOSE)) plot <- plot_dvtime(data, dv_var = c(DV = \"ODV\"), cent = \"median\", col_var = \"Dose\") #> Warning: The `fun.y` argument of `stat_summary()` is deprecated as of ggplot2 3.3.0. #> ℹ Please use the `fun` argument instead. #> ℹ The deprecated feature was likely used in the pmxhelpr package. #>   Please report the issue at <https://github.com/ryancrass/pmxhelpr/issues>. plot #> Warning: Removed 205 rows containing non-finite outside the scale range #> (`stat_summary()`). #> Warning: Removed 205 rows containing non-finite outside the scale range #> (`stat_summary()`). #> Warning: Removed 205 rows containing missing values or values outside the scale range #> (`geom_point()`)."},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_legend.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a legend for a visual predictive check (VPC) — plot_legend","title":"Plot a legend for a visual predictive check (VPC) — plot_legend","text":"Plot legend visual predictive check (VPC)","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_legend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a legend for a visual predictive check (VPC) — plot_legend","text":"","code":"plot_legend(   ci = c(0.05, 0.95),   pi = c(0.05, 0.95),   shown = NULL,   lloq = NULL,   update = NULL,   ... )"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_legend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a legend for a visual predictive check (VPC) — plot_legend","text":"ci simulated confidence interval plotted. match argument passed vpc::vpc(). Default c(0.05, 0.95). pi prediction intervals plotted. match argument passed vpc::vpc(). Default c(0.05, 0.95). shown Named list logicals specifying layers include plot. Passed show argument vpc::vpc(). Defaults : Observed points: obs_dv = TRUE. Observed quantiles: obs_ci = TRUE Simulated inter-quantile range:pi = FALSE Simulated inter-quantile area: pi_as_area = FALSE Simulated Quantile CI: pi_ci = TRUE Observed Median: obs_median = TRUE Simulated Median: sim_median = FALSE Simulated Median CI: sim_median_ci = TRUE lloq label lower limit quantification plot legend. update list containing plot elements updated. Default set vpc::new_vpc_theme(). ... arguments passed ggplot2::theme().","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_legend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a legend for a visual predictive check (VPC) — plot_legend","text":"ggplot2 object","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_legend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a legend for a visual predictive check (VPC) — plot_legend","text":"","code":"plot_legend()  plot_legend( pi = c(0.025, 0.975), ci = c(0.025, 0.925),  shown = list(obs_dv = FALSE, obs_ci = TRUE,  pi = FALSE, pi_as_area = FALSE, pi_ci = TRUE,  obs_median = TRUE,  sim_median =FALSE, sim_median_ci = TRUE))"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_vpc_exactbins.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a visual predictive check (VPC) with exact time bins — plot_vpc_exactbins","title":"Plot a visual predictive check (VPC) with exact time bins — plot_vpc_exactbins","text":"plot_vpc_exactbins() wrapper function vpc::vpc() returns ggplot2 object.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_vpc_exactbins.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a visual predictive check (VPC) with exact time bins — plot_vpc_exactbins","text":"","code":"plot_vpc_exactbins(   sim,   pcvpc = FALSE,   time_vars = c(TIME = \"TIME\", NTIME = \"NTIME\"),   output_vars = c(PRED = \"PRED\", IPRED = \"IPRED\", SIMDV = \"SIMDV\", OBSDV = \"OBSDV\"),   loq = NULL,   strat_var = NULL,   irep_name = \"SIM\",   min_bin_count = 1,   show_rep = TRUE,   lower_bound = 0,   shown = NULL,   theme = NULL,   ... )"},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_vpc_exactbins.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a visual predictive check (VPC) with exact time bins — plot_vpc_exactbins","text":"sim Input dataset. Must contain following variables: \"ID\", \"TIME\" pcvpc logical prediction correction. Default FALSE. time_vars Names actual nominal time variables. Must named character vector. Defaults \"TIME\" \"NTIME\". output_vars Names model outputs model. Must named character vector. Defaults \"PRED\", \"IPRED\", \"DV\". Currently \"IPRED\" \"DV\" required model@capture. loq Numeric value lower limit quantification (LLOQ) assay. Passed lloq argument vpc::vpc(). Specifying argument implies OBSDVis missing sim < LLOQ. strat_var Character string stratification variable passed stratify argument vpc::vpc(). Currently, single stratifying variable supported. irep_name Name replicate variable data. Must string. Default \"SIM\". min_bin_count Minimum number quantifiable observations exact bin inclusion binned plot layers. argument drops small bins summary statistic calculation retains observations observed data points. show_rep Display number replicates plot caption. Default TRUE. lower_bound Lower bound dependent variable prediction correction. Default 0. shown Named list logicals specifying layers include plot. Passed show argument vpc::vpc(). Defaults : Observed points: obs_dv = TRUE. Observed quantiles: obs_ci = TRUE Simulated inter-quantile range:pi = FALSE Simulated inter-quantile area: pi_as_area = FALSE Simulated Quantile CI: pi_ci = TRUE Observed Median: obs_median = TRUE Simulated Median: sim_median = FALSE Simulated Median CI: sim_median_ci = TRUE theme Named list aesthetic parameters plot.Passed vpc_theme arumgent vpc::vpc(). Defaults can obtained running vpc::new_vpc_theme() arguments. ... arguments passed vpc::vpc().","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_vpc_exactbins.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a visual predictive check (VPC) with exact time bins — plot_vpc_exactbins","text":"list containing calculated VPC information (vpcdb=TRUE), ggplot2 object (default)","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/reference/plot_vpc_exactbins.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a visual predictive check (VPC) with exact time bins — plot_vpc_exactbins","text":"","code":"model <- model_mread_load(model = \"model\") #> Loading model from cache. simout <- df_mrgsim_replicate(data = data_sad, model = model, replicates = 100, output_vars = c(DV = \"ODV\"), num_vars = c(\"CMT\", \"EVID\", \"MDV\", \"NTIME\", \"LLOQ\", \"WTBL\", \"FOOD\"), char_vars = c(\"USUBJID\", \"PART\"), irep_name = \"SIM\")  vpc_plot <- plot_vpc_exactbins( sim = simout, pcvpc = TRUE, pi = c(0.05, 0.95), ci = c(0.05, 0.95), loq = 1, log_y = TRUE) #> Joining with `by = join_by(CMT, NTIME)` #> Joining with `by = join_by(CMT, NTIME)` #> Prediction-correction cannot be used together with censored data (<LLOQ or >ULOQ). VPC plot will be shown for non-censored data only!"},{"path":[]},{"path":"https://ryancrass.github.io/pmxhelpr/news/index.html","id":"pmxhelpr-014","dir":"Changelog","previous_headings":"","what":"pmxhelpr 0.1.4","title":"pmxhelpr 0.1.4","text":"Fixed bug leading error generating stratified vpcs using strat_var argument","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/news/index.html","id":"pmxhelpr-013","dir":"Changelog","previous_headings":"","what":"pmxhelpr 0.1.3","title":"pmxhelpr 0.1.3","text":"Vignette vpc plot axes updated time unit breaks Vignette bullet point lists updated correct spacing Coerce argument lloq argument plot_legend() character type","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/news/index.html","id":"pmxhelpr-012","dir":"Changelog","previous_headings":"","what":"pmxhelpr 0.1.2","title":"pmxhelpr 0.1.2","text":"Vignettes copy edited","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/news/index.html","id":"pmxhelpr-011","dir":"Changelog","previous_headings":"","what":"pmxhelpr 0.1.1","title":"pmxhelpr 0.1.1","text":"Added dependency: patchwork","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/news/index.html","id":"pmxhelpr-010","dir":"Changelog","previous_headings":"","what":"pmxhelpr 0.1.0","title":"pmxhelpr 0.1.0","text":"Full VPC workflow now available Version 0.1.0 three vignettes demonstrate functionality! VPC Plot Aeesthetics vignette demonstrating options modifying plot aesthetics, creating plot legend using plot_legend(), adding VPC plot legend objects together single object using patchwork package","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/news/index.html","id":"pmxhelpr-003","dir":"Changelog","previous_headings":"","what":"pmxhelpr 0.0.3","title":"pmxhelpr 0.0.3","text":"Additional functionality plot_vpc_exactbins shown argument added facilitate customization layers shown plot standardize new function plot_legend. Passed show argument vpc::vpc() plot_legend helper function generate legend VPC plot generated using plot_vpc_exactbins(), can combined VPC plot using patchwork package VPC Plots BLQ Censoring vignette demonstrating appropriate handling data missing due assay sensitivity (lower limit quantification) using plot_vpc_exactbins() workflow leveraging df_mrgsim_replicate.","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/news/index.html","id":"pmxhelpr-002","dir":"Changelog","previous_headings":"","what":"pmxhelpr 0.0.2","title":"pmxhelpr 0.0.2","text":"loq argument added facilitate incorporating BLQ censoring observed data summary quantiles Bug fix allow passing argument vpcdb = TRUE vpc::vpc()","code":""},{"path":"https://ryancrass.github.io/pmxhelpr/news/index.html","id":"pmxhelpr-001","dir":"Changelog","previous_headings":"","what":"pmxhelpr 0.0.1","title":"pmxhelpr 0.0.1","text":"data_sad NONMEM mrgsolve analysis-ready dataset hypothetical SAD study assessment food effect. model mrgsolve model file (class mrgmod) internal pmxhelpr model library . model_load function load internal models pmxhelpr model library. df_mrgsim_replicate mrgsim wrapper function run simulation replicates input dataset multiple times, intended application generating Visual Predictive Check (VPC) simulation-based model diagnostics. plot_vpc_exactbins vpc wrapper function using exact time binning variable input dataset (e.g. nominal time) plotting observed data points using actual time. VPC Plots Exact Bins vignette demostrating use case plot_vpc_exactbins() workflow leveraging df_mrgsim_replicate.","code":""}]
